# Auth Service Implementation Guide

## Overview

The `AuthService` is the core authentication layer for the Kundali astrology Flutter app. It handles all authentication operations including login, signup, token management, and user session management.

### Architecture Layers

```
┌─────────────────────────────────────────────────────────────┐
│                     UI Layer (Screens)                       │
│            LoginScreen, SignupScreen, ProfileScreen          │
└────────────────────────┬────────────────────────────────────┘
                         │
┌─────────────────────────▼────────────────────────────────────┐
│                  State Management Layer                       │
│          AuthNotifier (Riverpod StateNotifier)               │
└────────────────────────┬────────────────────────────────────┘
                         │
┌─────────────────────────▼────────────────────────────────────┐
│                   Service Layer                              │
│                    AuthService                               │
│  - login()        - signup()      - logout()                │
│  - refreshToken() - getCurrentUser()                         │
│  - Token storage & validation                                │
│  - Error handling & exception mapping                        │
└────────────────────────┬────────────────────────────────────┘
                         │
┌─────────────────────────▼────────────────────────────────────┐
│                    API Layer                                 │
│                  ApiClient (Dio)                             │
│  - HTTP requests with JWT interceptor                        │
│  - Automatic token injection in headers                      │
│  - Error handling & response mapping                         │
└────────────────────────┬────────────────────────────────────┘
                         │
┌─────────────────────────▼────────────────────────────────────┐
│                  Backend API                                 │
│  - /auth/login, /auth/signup, /auth/refresh-token           │
│  - /auth/me, /auth/logout                                    │
└─────────────────────────────────────────────────────────────┘
```

---

## Implementation Details

### 1. AuthService Class Structure

#### Core Responsibilities

1. **Authentication Methods**
   - `login(email, password)` - User login
   - `signup(request)` - User registration
   - `logout()` - User logout

2. **Token Management**
   - `refreshAccessToken()` - Refresh expired tokens
   - `getCurrentUser()` - Fetch current user data
   - Token storage in SharedPreferences
   - Token validation and expiry checks

3. **Data Access**
   - Store/retrieve tokens from SharedPreferences
   - Cache current user data
   - Load user session on app startup

4. **Error Handling**
   - Convert DioException to custom exceptions
   - Map HTTP status codes to specific auth errors
   - Provide user-friendly error messages

#### Key Properties

```dart
// Token Properties
String? get accessToken      // Returns valid access token or null
String? get refreshToken     // Returns refresh token or null
UserData? get currentUser    // Returns cached user data or null

// Validation Properties
bool isTokenValid()          // Check if token exists and not expired
DateTime? getTokenExpiry()   // Get exact expiry time
```

#### Storage Keys

```dart
static const String _accessTokenKey = 'access_token';
static const String _refreshTokenKey = 'refresh_token';
static const String _userDataKey = 'user_data';
static const String _tokenExpiryKey = 'token_expiry';
```

---

## Method Documentation

### Authentication Methods

#### 1. login()

Authenticates a user with email and password.

**Signature:**
```dart
Future<AuthResponse> login({
  required String email,
  required String password,
}) async
```

**Implementation Flow:**
```
1. Create LoginRequest with email/password
2. Make POST /auth/login request via ApiClient
3. Validate HTTP response status (200)
4. Parse response into AuthResponse
5. Save tokens and user data to SharedPreferences
6. Return AuthResponse
```

**Example Usage:**
```dart
try {
  final response = await authService.login(
    email: 'user@example.com',
    password: 'password123',
  );
  print('Logged in as: ${response.user.email}');
  // AuthNotifier automatically updates state
} on InvalidCredentialsException {
  showErrorDialog('Invalid email or password');
} on NetworkException {
  showErrorDialog('Network error. Check your internet connection.');
} on AuthException catch (e) {
  showErrorDialog(e.message);
}
```

**Error Handling:**
- `InvalidCredentialsException` (401) - Wrong email/password
- `NetworkException` - No internet or timeout
- `AuthException` - Other auth errors

**Response:**
```dart
AuthResponse {
  accessToken: "eyJhbGc...",
  refreshToken: "eyJhbGc...",
  tokenType: "bearer",
  expiresIn: 3600,
  user: UserData {
    id: "123",
    email: "user@example.com",
    username: "user",
    fullName: "User Name",
    ...
  }
}
```

---

#### 2. signup()

Creates a new user account and automatically logs them in.

**Signature:**
```dart
Future<AuthResponse> signup(SignupRequest request) async
```

**Implementation Flow:**
```
1. Prepare SignupRequest with user details
2. Make POST /auth/signup request via ApiClient
3. Validate HTTP response status (200 or 201)
4. Parse response into AuthResponse
5. Save tokens and user data to SharedPreferences
6. Return AuthResponse
```

**Example Usage:**
```dart
try {
  final request = SignupRequest(
    email: 'newuser@example.com',
    password: 'password123',
    username: 'newuser',
    fullName: 'New User',
  );

  final response = await authService.signup(request);
  print('Account created for: ${response.user.email}');
  // AuthNotifier automatically updates state
} on UserAlreadyExistsException {
  showErrorDialog('Email already registered. Please login instead.');
} on RegistrationFailedException catch (e) {
  showErrorDialog('Registration failed: ${e.message}');
} on NetworkException {
  showErrorDialog('Network error. Check your internet connection.');
}
```

**Error Handling:**
- `UserAlreadyExistsException` (400) - Email already registered
- `RegistrationFailedException` (400) - Validation error
- `NetworkException` - No internet or timeout
- `AuthException` - Other auth errors

**Request Format:**
```json
{
  "email": "newuser@example.com",
  "password": "password123",
  "username": "newuser",
  "full_name": "New User"
}
```

---

#### 3. refreshAccessToken()

Refreshes an expired access token using the refresh token.

**Signature:**
```dart
Future<TokenResponse> refreshAccessToken() async
```

**Implementation Flow:**
```
1. Retrieve stored refresh token
2. Validate refresh token exists
3. Make POST /auth/refresh-token request
4. Validate HTTP response status (200)
5. Parse response into TokenResponse
6. Update stored access token and expiry time
7. Return TokenResponse
```

**Example Usage:**
```dart
try {
  final response = await authService.refreshAccessToken();
  print('Token refreshed successfully');
  // AuthNotifier will update state with new tokens
} on TokenExpiredException {
  // Refresh token expired, logout user
  await authService.logout();
  showErrorDialog('Session expired. Please login again.');
} on InvalidTokenException {
  // No refresh token available
  await authService.logout();
  showErrorDialog('Please login again.');
} on NetworkException {
  // Network error - could retry later
  showErrorDialog('Network error. Will retry automatically.');
}
```

**Token Lifecycle:**
```
Access Token (short-lived, ~1 hour)
├─ Sent with every API request
├─ Checked for expiry before requests
└─ Refreshed when < 5 minutes remain

Refresh Token (long-lived, ~7 days)
├─ Stored securely in SharedPreferences
├─ Used only for token refresh
└─ Cannot be used for API requests
```

**Automatic Refresh:**
- AuthNotifier schedules automatic refresh when 5 minutes remain
- No manual calls needed in most cases
- Transparent to UI layer

---

#### 4. getCurrentUser()

Fetches fresh user data from the server.

**Signature:**
```dart
Future<UserData> getCurrentUser() async
```

**Implementation Flow:**
```
1. Make GET /auth/me request with stored access token
2. Validate HTTP response status (200)
3. Parse response into UserData
4. Update cached user data in memory
5. Update stored user data in SharedPreferences
6. Return UserData
```

**Example Usage:**
```dart
try {
  final user = await authService.getCurrentUser();
  print('User: ${user.email}');
  print('Full name: ${user.fullName}');

  // Update UI with fresh data
  setState(() {
    _currentUser = user;
  });
} on UnauthorizedException {
  // Token invalid or expired
  await authService.logout();
  showErrorDialog('Session expired. Please login again.');
} on NetworkException {
  // Could show cached data instead
  final cachedUser = authService.currentUser;
  if (cachedUser != null) {
    print('Showing cached user data');
  }
}
```

**Use Cases:**
1. After login/signup to get fresh user data
2. On app startup to validate token
3. When user taps "Refresh Profile" button
4. Before sensitive operations

**Response:**
```json
{
  "id": "123",
  "email": "user@example.com",
  "username": "user",
  "full_name": "User Name",
  "is_active": true,
  "is_verified": true,
  "created_at": "2024-01-15T10:30:00Z",
  "last_login": "2024-01-20T15:45:00Z"
}
```

---

#### 5. logout()

Logs out the current user and clears all authentication data.

**Signature:**
```dart
Future<void> logout() async
```

**Implementation Flow:**
```
1. Attempt POST /auth/logout (optional, non-blocking)
2. Clear all stored tokens from SharedPreferences
3. Clear cached user data
4. Return (no error even if logout endpoint fails)
```

**Example Usage:**
```dart
await authService.logout();

// User is now logged out
// Tokens cleared from storage
// UI should show login screen
```

**Error Handling:**
- No exceptions thrown even if logout endpoint fails
- Local tokens always cleared
- Safe to call multiple times

**Behavior:**
```dart
try {
  // Try to invalidate token on backend
  await _apiClient.post('/auth/logout');
} catch (e) {
  // Ignore errors - token is already being cleared
}
finally {
  // Always clear local data
  await _clearTokens();
}
```

---

### Token Management Methods

#### Token Validation

**isTokenValid()**
```dart
bool isTokenValid()
```
- Returns `true` if access token exists and hasn't expired
- Returns `false` if no token or if expired
- Used before making authenticated API calls

**getTokenExpiry()**
```dart
DateTime? getTokenExpiry()
```
- Returns the exact DateTime when token expires
- Returns `null` if no token stored
- Used to calculate time remaining

**Example:**
```dart
// Check if token is still valid
if (authService.isTokenValid()) {
  // Make authenticated request
  final user = await authService.getCurrentUser();
} else {
  // Refresh token or ask user to login
  try {
    await authService.refreshAccessToken();
  } on InvalidTokenException {
    showLoginScreen();
  }
}

// Get time remaining
final expiry = authService.getTokenExpiry();
if (expiry != null) {
  final remaining = expiry.difference(DateTime.now());
  print('Token expires in ${remaining.inMinutes} minutes');
}
```

---

## Error Handling

### Exception Hierarchy

```
AuthException (base class)
├── InvalidCredentialsException
│   ├── 401 Unauthorized
│   └── Invalid email or password
│
├── InvalidTokenException
│   ├── 401 Unauthorized
│   └── No refresh token available
│
├── TokenExpiredException
│   ├── 401 Unauthorized
│   └── Token has expired
│
├── UnauthorizedException
│   ├── 401/403 Forbidden
│   └── Unauthorized access
│
├── UserAlreadyExistsException
│   ├── 400 Bad Request
│   └── Email already registered
│
├── RegistrationFailedException
│   ├── 400 Bad Request
│   └── Registration validation error
│
└── NetworkException
    ├── Timeout
    ├── Connection error
    └── No internet

```

### Error Mapping

#### HTTP Status Codes

```dart
400 → Bad Request
  ├─ "already exists" → UserAlreadyExistsException
  ├─ "invalid" → InvalidCredentialsException
  └─ default → RegistrationFailedException

401 → Unauthorized
  └─ → InvalidCredentialsException

403 → Forbidden
  └─ → UnauthorizedException

5xx → Server Error
  └─ → AuthException
```

#### DioException Types

```dart
DioExceptionType.connectionTimeout
DioExceptionType.sendTimeout
DioExceptionType.receiveTimeout
  └─ → NetworkException("Connection timeout...")

DioExceptionType.badResponse
  └─ → Map to HTTP status code

DioExceptionType.connectionError
  └─ → NetworkException("Network error...")

DioExceptionType.cancel
  └─ → AuthException("Request cancelled")

DioExceptionType.unknown
  └─ → AuthException("An unexpected error occurred")
```

### Error Extraction

The service extracts error messages from response in this order:
1. `response.data['detail']` - FastAPI style
2. `response.data['message']` - Generic message field
3. `response.data['error']` - Error field
4. `response.data['errors']` - Map of field errors
5. Generic message with status code

### Example Error Handling

```dart
Future<void> handleLogin(String email, String password) async {
  try {
    final response = await authService.login(
      email: email,
      password: password,
    );
    // Success - AuthNotifier updates state
    print('Login successful');
  } on InvalidCredentialsException catch (e) {
    // Handle invalid credentials
    showSnackBar('Invalid email or password');
  } on UserAlreadyExistsException catch (e) {
    // Handle account already exists (shouldn't happen on login)
    showSnackBar('Account already exists');
  } on NetworkException catch (e) {
    // Handle network errors
    showSnackBar('Network error: ${e.message}');
    // Could offer retry option
  } on AuthException catch (e) {
    // Handle other auth errors
    showSnackBar('Auth error: ${e.message}');
  } catch (e) {
    // Handle unexpected errors
    showSnackBar('Unexpected error: $e');
  }
}
```

---

## Integration with Other Components

### 1. Integration with ApiClient

The AuthService integrates with ApiClient through:
- SharedPreferences - passed during init
- Dependency injection of ApiClient instance

**Automatic JWT Injection:**
```dart
// ApiClient's JWT Interceptor automatically adds token to headers
_JwtInterceptor {
  onRequest(options) {
    final token = authService?.accessToken;
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
  }
}
```

**No manual header management needed** - tokens automatically injected.

### 2. Integration with AuthNotifier

AuthNotifier uses AuthService methods:

```dart
// In AuthNotifier
Future<void> login({required String email, required String password}) async {
  try {
    // Call AuthService.login()
    final response = await _authService.login(
      email: email,
      password: password,
    );

    // Update Riverpod state
    state = AuthStateAuthenticated(
      user: response.user,
      accessToken: response.accessToken,
      refreshToken: response.refreshToken,
      expiresIn: response.expiresIn,
      expiryTime: expiryTime,
    );
  } catch (e) {
    // Handle error
    state = AuthStateUnauthenticated(errorMessage: e.message);
    rethrow;
  }
}
```

**Division of Responsibility:**
- `AuthService` - API calls, token storage, validation
- `AuthNotifier` - State management, automatic token refresh, UI state

### 3. Integration with UI Screens

Screens interact through Riverpod providers:

```dart
// In LoginScreen
ref.read(authProvider.notifier).login(
  email: emailController.text,
  password: passwordController.text,
);

// Watching state
final authState = ref.watch(authProvider);

if (authState is AuthStateLoading) {
  showLoadingSpinner();
} else if (authState is AuthStateAuthenticated) {
  navigateToHome();
} else if (authState is AuthStateUnauthenticated) {
  showError(authState.errorMessage);
}
```

---

## Data Models

### AuthResponse

```dart
class AuthResponse {
  final String accessToken;      // JWT token for API requests
  final String refreshToken;      // Token for refreshing access token
  final String tokenType;         // Usually "bearer"
  final int expiresIn;            // Token lifetime in seconds
  final UserData user;            // Authenticated user data
}
```

### TokenResponse

```dart
class TokenResponse {
  final String accessToken;      // New JWT token
  final String refreshToken;      // New refresh token (optional)
  final String tokenType;         // Usually "bearer"
  final int expiresIn;            // Token lifetime in seconds
}
```

### UserData

```dart
class UserData {
  final String id;                // User ID
  final String email;             // User email
  final String username;          // Username
  final String? fullName;         // Full name
  final bool isActive;            // Account active
  final bool isVerified;          // Email verified
  final DateTime createdAt;       // Account creation date
  final DateTime? lastLogin;      // Last login timestamp
}
```

---

## Initialization

### In main.dart

```dart
import 'package:shared_preferences/shared_preferences.dart';
import 'package:client/data/services/api_client.dart';
import 'package:client/data/services/auth_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize ApiClient
  final apiClient = ApiClient();
  apiClient.init(
    baseUrl: 'http://localhost:8000/api',
  );

  // Initialize AuthService
  final authService = AuthService();
  final prefs = await SharedPreferences.getInstance();

  await authService.init(
    apiClient: apiClient,
    preferences: prefs,
  );

  // Now pass to ApiClient so it can use authService for JWT injection
  // This is already done in auth_provider.dart

  runApp(
    ProviderScope(
      child: MyApp(
        authService: authService,
      ),
    ),
  );
}
```

### Initialization Checklist

- [ ] ApiClient initialized with correct baseUrl
- [ ] AuthService.init() called with ApiClient and SharedPreferences
- [ ] AuthService added to Provider dependencies
- [ ] ProviderScope wrapping MaterialApp
- [ ] AuthNotifier receiving initialized AuthService

---

## Testing

### Mock Implementation

```dart
class MockAuthService implements AuthService {
  @override
  Future<AuthResponse> login({
    required String email,
    required String password,
  }) async {
    if (email == 'valid@example.com' && password == 'password123') {
      return AuthResponse(
        accessToken: 'mock_access_token',
        refreshToken: 'mock_refresh_token',
        tokenType: 'bearer',
        expiresIn: 3600,
        user: UserData(
          id: '123',
          email: 'valid@example.com',
          username: 'validuser',
          fullName: 'Valid User',
          createdAt: DateTime.now(),
        ),
      );
    }
    throw InvalidCredentialsException();
  }

  @override
  Future<AuthResponse> signup(SignupRequest request) async {
    // Mock implementation
    throw UnimplementedError();
  }

  // ... implement other methods
}
```

### Unit Tests

```dart
void main() {
  group('AuthService', () {
    late MockSharedPreferences mockPrefs;
    late MockApiClient mockApiClient;
    late AuthService authService;

    setUp(() {
      mockPrefs = MockSharedPreferences();
      mockApiClient = MockApiClient();
      authService = AuthService();
      // Initialize with mocks
    });

    test('login stores tokens on success', () async {
      // Arrange
      when(mockApiClient.post(...))
          .thenAnswer((_) async => mockAuthResponse);

      // Act
      final response = await authService.login(
        email: 'test@example.com',
        password: 'password',
      );

      // Assert
      expect(response.user.email, 'test@example.com');
      verify(mockPrefs.setString('access_token', ...)).called(1);
    });

    test('login throws on invalid credentials', () async {
      // Arrange
      when(mockApiClient.post(...))
          .thenThrow(DioException(...status: 401...));

      // Act & Assert
      expect(
        () => authService.login(
          email: 'wrong@example.com',
          password: 'wrongpass',
        ),
        throwsA(isA<InvalidCredentialsException>()),
      );
    });
  });
}
```

---

## Common Patterns

### Pattern 1: Login Flow

```dart
// Step 1: User enters credentials and taps login
final response = ref.read(authProvider.notifier).login(
  email: emailController.text,
  password: passwordController.text,
);

// Step 2: AuthNotifier calls AuthService.login()
// Step 3: AuthService makes API request and stores tokens
// Step 4: AuthNotifier updates state to AuthStateAuthenticated
// Step 5: UI rebuilds and navigates to home screen
```

### Pattern 2: Token Refresh

```dart
// Automatic (transparent to UI)
if (authService.isTokenValid()) {
  // Use existing token
  final response = await apiClient.get('/protected-endpoint');
} else {
  // Refresh token automatically
  try {
    await authService.refreshAccessToken();
    // Retry original request with new token
  } on InvalidTokenException {
    // Refresh failed - logout user
    await authService.logout();
  }
}
```

### Pattern 3: Logout

```dart
await ref.read(authProvider.notifier).logout();

// AuthNotifier calls authService.logout()
// AuthService clears tokens
// AuthNotifier updates state to AuthStateUnauthenticated
// UI navigates to login screen
```

### Pattern 4: Protected Route

```dart
bool isAuthenticated = ref.watch(isAuthenticatedProvider);

if (isAuthenticated) {
  return HomeScreen();
} else {
  return LoginScreen();
}
```

---

## Troubleshooting

### Issue: "AuthService not initialized"

**Solution:** Ensure init() is called in main.dart before using the service.

### Issue: Tokens not persisting across app restart

**Solution:** Check that:
1. SharedPreferences is initialized
2. _saveAuthResponse() is called after login/signup
3. Storage keys are correct
4. SharedPreferences is not being cleared

### Issue: JWT header not being added

**Solution:** Ensure:
1. AuthService passed to ApiClient during init
2. ApiClient has JwtInterceptor
3. accessToken property returns non-null value
4. Token is valid (not expired)

### Issue: Token refresh creates infinite loop

**Solution:** Check that:
1. Refresh endpoint returns new tokens
2. expiresIn is greater than 0
3. No circular dependency between services

---

## API Endpoint Reference

### POST /auth/login

**Request:**
```json
{
  "email": "user@example.com",
  "password": "password123"
}
```

**Response (200):**
```json
{
  "access_token": "eyJhbGc...",
  "refresh_token": "eyJhbGc...",
  "token_type": "bearer",
  "expires_in": 3600,
  "user": {
    "id": "123",
    "email": "user@example.com",
    "username": "user",
    "full_name": "User Name",
    "is_active": true,
    "is_verified": true,
    "created_at": "2024-01-15T10:30:00Z",
    "last_login": "2024-01-20T15:45:00Z"
  }
}
```

### POST /auth/signup

**Request:**
```json
{
  "email": "newuser@example.com",
  "password": "password123",
  "username": "newuser",
  "full_name": "New User"
}
```

**Response (201):**
Same as /auth/login

### POST /auth/refresh-token

**Request:**
```json
{
  "refresh_token": "eyJhbGc..."
}
```

**Response (200):**
```json
{
  "access_token": "eyJhbGc...",
  "refresh_token": "eyJhbGc...",
  "token_type": "bearer",
  "expires_in": 3600
}
```

### GET /auth/me

**Headers:**
```
Authorization: Bearer <access_token>
```

**Response (200):**
```json
{
  "id": "123",
  "email": "user@example.com",
  "username": "user",
  "full_name": "User Name",
  "is_active": true,
  "is_verified": true,
  "created_at": "2024-01-15T10:30:00Z",
  "last_login": "2024-01-20T15:45:00Z"
}
```

### POST /auth/logout

**Headers:**
```
Authorization: Bearer <access_token>
```

**Response (200):**
```json
{
  "message": "Successfully logged out"
}
```

---

## Summary

The AuthService provides a complete authentication solution with:
- Full login/signup/logout flows
- Automatic token management and refresh
- Secure token storage in SharedPreferences
- Comprehensive error handling
- Seamless integration with ApiClient and Riverpod
- Type-safe exception handling

All authentication logic is centralized in this single service, making it easy to test, maintain, and update.
